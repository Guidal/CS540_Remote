# -*- coding: utf-8 -*-
"""Butterpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NmBqr5CGjDfPSvUROb-fDDddQu8aBna5
"""

import numpy as np
import astropy
!pip install git+https://github.com/zclaytor/butterpy
import butterpy as bp
!pip install fleck
import fleck as fl
import matplotlib.pyplot as plt
from astropy.timeseries import LombScargle

"""# Fleck"""

from fleck import generate_spots

spot_contrast = 0.1
#u_ld = [0.5079, 0.2239]
u_ld = [1,0]

n_phases = 1
n_inclinations = 1
n_spots = 2

spot_radius = 0.1   # Rspot/Rstar
min_latitude = 70   # deg
max_latitude = 90   # deg

lons, lats, radii, inc_stellar = generate_spots(min_latitude, max_latitude,
                                                spot_radius, n_spots,
                                                n_inclinations=n_inclinations)
times = np.linspace(0, 30, 100000)

print(radii)

from fleck import Star

star = Star(spot_contrast=spot_contrast, n_phases=n_phases, u_ld=u_ld, rotation_period=6.3)
star2 = Star(spot_contrast=spot_contrast, n_phases=n_phases, u_ld=u_ld, rotation_period=11.2)

print(inc_stellar)

import astropy.units as u

custom_lons1 = u.Quantity([[57.0],[57.0+90]] * u.deg) # 57 and 237 for true double-dipper
custom_lons2 = u.Quantity([[57.0],[57.0]] * u.deg)
custom_lats = u.Quantity([[0.01],[0.01]] * u.deg)
#custom_lons1 = u.Quantity([57.0] * u.deg)
#custom_lons2 = u.Quantity([37+90.0] * u.deg)
#custom_lats = u.Quantity([0.0] * u.deg)
custom_incl = u.Quantity([0.01] * u.deg)
print(custom_incl)
print(type(custom_incl))
print(custom_incl.shape)

#lcs = star.light_curve(lons, lats, radii, inc_stellar,times=times)
#lcs2 = star2.light_curve(lons, lats, radii, inc_stellar,times=times)
lcs = star.light_curve(custom_lons1, custom_lats, radii, custom_incl,times=times)
lcs2 = star2.light_curve(custom_lons2, custom_lats, radii, custom_incl,times=times)

print(lcs.reshape(-1).shape)
print(lcs2.reshape(-1).shape)

# Normalize lcs to between 0 and 1
normalized_lcs = (lcs - np.min(lcs)) / (np.max(lcs) - np.min(lcs))
normalized_lcs2 = (lcs2 - np.min(lcs2)) / (np.max(lcs2) - np.min(lcs2))

fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

ax1.plot(times, normalized_lcs)
ax1.axvline(x=6.3)
#ax1.axvline(x=25) If you are trying to make a double-dipper, then this make it easier to see.
#ax1.axhline(y=0.5) # This is where the light curve starts if longitude is 45
ax1.set_title('Normalized LC 1')
ax1.set_ylabel('Normalized Flux')
ax1.set_xlabel('Time')

ax2.plot(times, normalized_lcs2)
ax2.axvline(x=11.2)
ax2.set_title('Normalized LC 2')
ax2.set_ylabel('Normalized Flux')
ax2.set_xlabel('Time')

ax3.plot(times, normalized_lcs+0.8*normalized_lcs2)
ax3.axvline(x=6.3)
ax3.axvline(x=11.2)
ax3.set_title('Combined Normalized LC')
ax3.set_ylabel('Normalized Flux')
ax3.set_xlabel('Time')

plt.show()

def astro_LombScargle2(x,y_err,period1,period2):
  import numpy as np
  from astropy.timeseries import LombScargle
  from scipy.signal import find_peaks

  percentErr = np.array([])

  print(x.shape)
  print(y_err.shape)

  ls = LombScargle(x,y_err)

  #frequencies = np.linspace(0,100,nout)
  #power = ls.power(frequencies)
  frequencies, power = ls.autopower(normalization='standard')
  time = 1/frequencies

  peak_ind = find_peaks(power, height=0.1)
  temp = peak_ind[0]

  p1 = time[temp[0]]
  p1Err = 100*(abs(period1-p1)/period1)

  p2 = time[temp[1]]
  p2Err = 100*(abs(period2-p2)/period2)

  #plt.xlim(0,3*np.round(p1))
  plt.xlim(0,30)
  plt.plot(time,power)
  plt.axvline(x=period1)
  plt.axvline(x=period2)
  #print(len(peak_ind[0]))
  return p1,p2,p1Err,p2Err

period1 = 6.3
period2 = 11.2
x = times
y = normalized_lcs.reshape(-1) + (0.8*normalized_lcs2.reshape(-1))
p1,p2,p1Err,p2Err = astro_LombScargle2(x,y,period1,period2)

print(p1)
print(p1Err)
print(p2)
print(p2Err)

"""# ButterPy"""

# Initialize surface. You almost never need to supply arguments.
s = bp.Surface()

# Will add code testing out Surface.add_region(), it should add a single spot.
# Will also try out Fleck, github at https://github.com/bmorris3/fleck. Claytor says
# it is designed for adding single/multiple spots of specific sizes at specific locations.

# Emerge active regions
regions = s.emerge_regions(
  butterfly=True,
  ndays=1000,
  activity_level=1,
  cycle_period=11,
  cycle_overlap=2,
  min_lat=50,
  max_lat=60,
  )

# From active regions, compute spot evolution and light curve
lightcurve = s.evolve_spots(
  inclination=80,
  period=24.5,
  shear=0.2,
)

# Plot butterfly diagram and light curve
s.plot_butterfly()
plt.tight_layout()

s.plot_lightcurve()
plt.tight_layout()

lightcurve.flux

s2 = bp.Surface()

# Emerge active regions
regions2 = s2.emerge_regions(
  butterfly=True,
  ndays=1000,
  activity_level=1,
  cycle_period=4,
  cycle_overlap=2,
  min_lat=30,
  max_lat=40,
  )

# From active regions, compute spot evolution and light curve
lightcurve2 = s2.evolve_spots(
  inclination=40,
  period=16.5,
  shear=0.2,
)
s2.plot_butterfly()
plt.tight_layout()

s2.plot_lightcurve()
plt.tight_layout()

lightcurve2.flux

blendCurve = lightcurve.flux + lightcurve2.flux

plt.plot(lightcurve.time,blendCurve)

def astro_LombScargle2(x,y_err,period1,period2):
  import numpy as np
  from astropy.timeseries import LombScargle
  from scipy.signal import find_peaks

  percentErr = np.array([])

  print(x.shape)
  print(y_err.shape)

  ls = LombScargle(x,y_err)

  #frequencies = np.linspace(0,100,nout)
  #power = ls.power(frequencies)
  frequencies, power = ls.autopower(normalization='standard')
  time = 1/frequencies

  peak_ind = find_peaks(power, height=0.01)
  temp = peak_ind[0]

  p1 = time[temp[0]]
  p1Err = 100*(abs(period1-p1)/period1)

  p2 = time[temp[1]]
  p2Err = 100*(abs(period2-p2)/period2)

  #plt.xlim(0,3*np.round(p1))
  plt.xlim(0,30)
  plt.plot(time,power)
  #print(len(peak_ind[0]))
  return p1,p2,p1Err,p2Err

period1 = 24.5
period2 = 16.5
x = lightcurve.time
y = blendCurve
p1,p2,p1Err,p2Err = astro_LombScargle2(x,y,period1,period2)

print(p1)
print(p1Err)
print(p2)
print(p2Err)

ls = LombScargle(x,y)
frequencies, power = ls.autopower(normalization='psd')
p1 = frequencies[np.argmax(power)]

plt.xlim(0,3*np.round(p1))
plt.plot(frequencies,power)

